===============================================================================
                  GUIA DE IMPLEMENTACION - GYMCORE SAAS
            Funcionalidades Pendientes para Completar la Aplicacion
===============================================================================

Este documento contiene los prompts detallados para implementar todas las 
funcionalidades faltantes en el sistema GymCore, organizados por area y 
prioridad.

===============================================================================
                         INDICE DE IMPLEMENTACION
===============================================================================

FASE 1: Backend - Endpoints de Configuracion y Perfil
  1. Endpoint para actualizar perfil de usuario
  2. Endpoint para actualizar perfil del gimnasio
  3. Endpoint para cambiar contraseña

FASE 2: Backend - Endpoints de Facturacion Avanzada
  4. Endpoint para cancelar suscripcion
  5. Endpoint para cambiar plan
  6. Endpoint para obtener historial de facturas
  7. Endpoint para actualizar metodo de pago

FASE 3: Backend - Recuperacion de Contraseña
  8. Endpoint para solicitar recuperacion de contraseña
  9. Endpoint para resetear contraseña con token

FASE 4: Backend - Sistema de Notificaciones
  10. Endpoint para obtener notificaciones del usuario

FASE 5: Frontend - Pantalla de Configuracion
  11. Implementar formulario de Perfil de Usuario
  12. Implementar formulario de Perfil del Gimnasio
  13. Implementar formulario de Cambio de Contraseña
  14. Implementar sistema de pestañas funcional

FASE 6: Frontend - Pantalla de Facturacion
  15. Conectar datos reales de suscripcion
  16. Implementar boton "Cancelar Suscripcion"
  17. Implementar boton "Cambiar Plan"
  18. Implementar boton "Actualizar Metodo de Pago"
  19. Implementar historial de facturas

FASE 7: Frontend - Recuperacion de Contraseña
  20. Crear pagina "Forgot Password"
  21. Crear pagina "Reset Password"
  22. Conectar con endpoints del backend

FASE 8: Frontend - Sistema de Notificaciones
  23. Implementar dropdown de notificaciones
  24. Conectar con endpoint del backend

===============================================================================
           FASE 1: BACKEND - ENDPOINTS DE CONFIGURACION Y PERFIL
===============================================================================

-------------------------------------------------------------------------------
Prompt 1.1: Endpoint para Actualizar Perfil de Usuario
-------------------------------------------------------------------------------

Crea un nuevo archivo llamado "users.py" en la carpeta 
"gymcore/backend/app/api/routes/" con el siguiente endpoint:

Ruta: PUT /api/users/me
Descripcion: Permite al usuario autenticado actualizar su nombre completo y 
email.
Autenticacion: Requiere JWT token valido.

Validaciones:
- El email debe ser valido y unico (no puede existir otro usuario con ese 
  email).
- El nombre completo no puede estar vacio.

Schema de Request (crear en "gymcore/backend/app/api/schemas/users.py"):

from pydantic import BaseModel, EmailStr
from typing import Optional

class UserUpdateRequest(BaseModel):
    full_name: Optional[str] = None
    email: Optional[EmailStr] = None

Logica:
1. Obtener el usuario actual desde el token JWT (usando "get_current_user").
2. Validar que si se cambia el email, no exista otro usuario con ese email.
3. Actualizar solo los campos enviados (full_name y/o email).
4. Retornar el usuario actualizado usando el schema "UserResponse".

Respuesta exitosa: 200 OK con el objeto "UserResponse".
Errores posibles:
- 400 Bad Request si el email ya existe.
- 401 Unauthorized si no hay token.

-------------------------------------------------------------------------------
Prompt 1.2: Endpoint para Actualizar Perfil del Gimnasio
-------------------------------------------------------------------------------

En el archivo "gymcore/backend/app/api/routes/users.py" (o crear "gyms.py"), 
añade el siguiente endpoint:

Ruta: PUT /api/gyms/me
Descripcion: Permite al administrador del gimnasio actualizar los datos del 
negocio.
Autenticacion: Requiere JWT token valido y rol de admin.

Validaciones:
- Solo el admin del gimnasio puede actualizar su gimnasio.
- El email del gimnasio debe ser unico si se cambia.

Schema de Request (crear en "gymcore/backend/app/api/schemas/gyms.py"):

from pydantic import BaseModel, EmailStr
from typing import Optional

class GymUpdateRequest(BaseModel):
    name: Optional[str] = None
    email: Optional[EmailStr] = None
    phone: Optional[str] = None
    address: Optional[str] = None

Logica:
1. Obtener el usuario actual desde el token JWT.
2. Verificar que el usuario tenga rol 'admin'.
3. Obtener el gimnasio asociado al usuario (current_user.gym_id).
4. Validar que si se cambia el email del gym, no exista otro gym con ese 
   email.
5. Actualizar solo los campos enviados.
6. Retornar el gimnasio actualizado usando el schema "GymResponse".

Respuesta exitosa: 200 OK con el objeto "GymResponse".
Errores posibles:
- 400 Bad Request si el email ya existe.
- 403 Forbidden si el usuario no es admin.
- 401 Unauthorized si no hay token.

-------------------------------------------------------------------------------
Prompt 1.3: Endpoint para Cambiar Contraseña
-------------------------------------------------------------------------------

En el archivo "gymcore/backend/app/api/routes/auth.py", añade el siguiente 
endpoint:

Ruta: POST /api/auth/change-password
Descripcion: Permite al usuario autenticado cambiar su contraseña actual.
Autenticacion: Requiere JWT token valido.

Validaciones:
- La contraseña actual debe ser correcta.
- La nueva contraseña debe tener al menos 8 caracteres.
- La nueva contraseña debe ser diferente a la actual.

Schema de Request (añadir a "gymcore/backend/app/api/schemas/auth.py"):

class ChangePasswordRequest(BaseModel):
    current_password: str
    new_password: str = Field(min_length=8)

Logica:
1. Obtener el usuario actual desde el token JWT.
2. Verificar que "current_password" coincida con "user.hashed_password" 
   usando "verify_password".
3. Validar que "new_password" sea diferente a "current_password".
4. Hashear la nueva contraseña usando "get_password_hash".
5. Actualizar "user.hashed_password" en la base de datos.
6. Retornar mensaje de exito.

Respuesta exitosa: 200 OK con {"message": "Password changed successfully"}
Errores posibles:
- 400 Bad Request si la contraseña actual es incorrecta.
- 400 Bad Request si la nueva contraseña es igual a la actual.
- 401 Unauthorized si no hay token.

===============================================================================
          FASE 2: BACKEND - ENDPOINTS DE FACTURACION AVANZADA
===============================================================================

-------------------------------------------------------------------------------
Prompt 2.1: Endpoint para Cancelar Suscripcion
-------------------------------------------------------------------------------

En el archivo "gymcore/backend/app/api/routes/billing.py", añade el siguiente 
endpoint:

Ruta: POST /api/billing/cancel-subscription
Descripcion: Cancela la suscripcion activa del gimnasio. El gimnasio 
permanece activo hasta el final del periodo pagado.
Autenticacion: Requiere JWT token valido y gimnasio activo.

Validaciones:
- Debe existir una suscripcion activa.
- Solo el admin puede cancelar.

Logica:
1. Obtener el usuario actual y verificar que sea admin.
2. Buscar la suscripcion activa del gimnasio usando 
   "SubscriptionRepository.get_active_by_gym()".
3. Actualizar la suscripcion:
   - status = 'cancelled'
   - cancelled_at = datetime.now()
   - Mantener end_date intacto (el gimnasio sigue activo hasta esa fecha).
4. Retornar mensaje de confirmacion con la fecha hasta la cual tendran 
   acceso.

Respuesta exitosa: 
{
  "message": "Subscription cancelled successfully",
  "access_until": "2026-01-18T00:00:00"
}

Errores posibles:
- 404 Not Found si no hay suscripcion activa.
- 403 Forbidden si el usuario no es admin.

-------------------------------------------------------------------------------
Prompt 2.2: Endpoint para Cambiar Plan
-------------------------------------------------------------------------------

En el archivo "gymcore/backend/app/api/routes/billing.py", añade el siguiente 
endpoint:

Ruta: POST /api/billing/change-plan
Descripcion: Cambia el plan de suscripcion del gimnasio (upgrade o 
downgrade).
Autenticacion: Requiere JWT token valido y gimnasio activo.

Schema de Request (añadir a "gymcore/backend/app/api/schemas/billing.py"):

class ChangePlanRequest(BaseModel):
    new_plan: str = Field(pattern='^(basic|pro|elite)$')

Logica:
1. Obtener el usuario actual y verificar que sea admin.
2. Validar que "new_plan" sea diferente al plan actual 
   (current_user.gym.plan_type).
3. Calcular el prorrateado:
   - Upgrade: Cobrar la diferencia inmediatamente.
   - Downgrade: Aplicar el cambio en la proxima renovacion.
4. Actualizar "gym.plan_type" en la base de datos.
5. Crear un registro en una nueva tabla "PlanChangeHistory" (opcional) para 
   auditoria.
6. Retornar confirmacion del cambio.

Respuesta exitosa:
{
  "message": "Plan changed successfully",
  "new_plan": "pro",
  "effective_date": "2025-12-18T00:00:00",
  "next_billing_date": "2026-01-18T00:00:00"
}

Errores posibles:
- 400 Bad Request si el plan es el mismo que el actual.
- 404 Not Found si no hay suscripcion activa.

-------------------------------------------------------------------------------
Prompt 2.3: Endpoint para Obtener Historial de Facturas
-------------------------------------------------------------------------------

En el archivo "gymcore/backend/app/api/routes/billing.py", añade el siguiente 
endpoint:

Ruta: GET /api/billing/invoices
Descripcion: Retorna el historial de todas las facturas/pagos del gimnasio.
Autenticacion: Requiere JWT token valido y gimnasio activo.

Logica:
1. Obtener el usuario actual.
2. Buscar todas las suscripciones del gimnasio ordenadas por fecha 
   descendente.
3. Para cada suscripcion, devolver:
   - ID de factura (puede ser el subscription.id)
   - Fecha del pago (start_date)
   - Monto (amount)
   - Plan (plan_type)
   - Estado (status)
4. Retornar la lista de facturas.

Schema de Response (crear en "gymcore/backend/app/api/schemas/billing.py"):

from typing import List
from datetime import datetime

class InvoiceResponse(BaseModel):
    id: int
    date: datetime
    amount: float
    plan: str
    status: str

    class Config:
        from_attributes = True

Respuesta exitosa: Lista de "InvoiceResponse".
Nota: Si no hay facturas, retornar lista vacia [].

-------------------------------------------------------------------------------
Prompt 2.4: Endpoint para Actualizar Metodo de Pago
-------------------------------------------------------------------------------

En el archivo "gymcore/backend/app/api/routes/billing.py", añade el siguiente 
endpoint:

Ruta: PUT /api/billing/payment-method
Descripcion: Actualiza el metodo de pago (tarjeta) asociado al gimnasio.
Autenticacion: Requiere JWT token valido y gimnasio activo.

Schema de Request (añadir a "gymcore/backend/app/api/schemas/billing.py"):

class UpdatePaymentMethodRequest(BaseModel):
    card_number: str = Field(min_length=16, max_length=16)
    expiry_month: int = Field(ge=1, le=12)
    expiry_year: int = Field(ge=2025)
    cvv: str = Field(min_length=3, max_length=4)

Logica (simulada, ya que no hay procesador de pagos real):
1. Obtener el usuario actual y verificar que sea admin.
2. Validar que la tarjeta no este expirada.
3. Crear o actualizar un registro en una nueva tabla "PaymentMethod":
   - gym_id
   - last_four (ultimos 4 digitos de card_number)
   - card_type (Visa/MasterCard, detectado por el primer digito)
   - expiry_month
   - expiry_year
   - is_active = True
4. Marcar metodos anteriores como is_active = False.
5. Retornar confirmacion.

Respuesta exitosa:
{
  "message": "Payment method updated successfully",
  "last_four": "4242",
  "card_type": "Visa"
}

Nota: Crear el modelo "PaymentMethodModel" en 
"gymcore/backend/app/infrastructure/database.py":

class PaymentMethodModel(Base):
    __tablename__ = "payment_methods"
    id = Column(Integer, primary_key=True, index=True)
    gym_id = Column(Integer, ForeignKey("gyms.id"))
    last_four = Column(String(4))
    card_type = Column(String(20))
    expiry_month = Column(Integer)
    expiry_year = Column(Integer)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

===============================================================================
              FASE 3: BACKEND - RECUPERACION DE CONTRASEÑA
===============================================================================

-------------------------------------------------------------------------------
Prompt 3.1: Endpoint para Solicitar Recuperacion de Contraseña
-------------------------------------------------------------------------------

En el archivo "gymcore/backend/app/api/routes/auth.py", añade el siguiente 
endpoint:

Ruta: POST /api/auth/forgot-password
Descripcion: Inicia el proceso de recuperacion de contraseña enviando un 
token de recuperacion.
Autenticacion: No requiere JWT (endpoint publico).

Schema de Request:

class ForgotPasswordRequest(BaseModel):
    email: EmailStr

Logica:
1. Buscar el usuario por email en la base de datos.
2. Si no existe, retornar 200 OK de todas formas (seguridad: no revelar si 
   el email existe).
3. Si existe:
   - Generar un token de recuperacion unico (puede ser un UUID).
   - Guardar el token en una nueva tabla "PasswordResetToken":
     - user_id
     - token (UUID)
     - expires_at (datetime, 1 hora desde ahora)
     - used = False
4. Simulacion de Email: En lugar de enviar email real, retornar el token en 
   la respuesta (solo para desarrollo).
5. Retornar mensaje generico.

Modelo de BD (añadir a "gymcore/backend/app/infrastructure/database.py"):

class PasswordResetTokenModel(Base):
    __tablename__ = "password_reset_tokens"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    token = Column(String(255), unique=True, index=True)
    expires_at = Column(DateTime)
    used = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)

Respuesta exitosa (desarrollo):
{
  "message": "If the email exists, a reset link will be sent",
  "dev_token": "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
}

-------------------------------------------------------------------------------
Prompt 3.2: Endpoint para Resetear Contraseña con Token
-------------------------------------------------------------------------------

En el archivo "gymcore/backend/app/api/routes/auth.py", añade el siguiente 
endpoint:

Ruta: POST /api/auth/reset-password
Descripcion: Restablece la contraseña del usuario usando un token valido.
Autenticacion: No requiere JWT (endpoint publico, usa token de recuperacion).

Schema de Request:

class ResetPasswordRequest(BaseModel):
    token: str
    new_password: str = Field(min_length=8)

Logica:
1. Buscar el token en "PasswordResetToken":
   - Debe existir.
   - No debe estar expirado (expires_at > now()).
   - No debe haber sido usado (used = False).
2. Si el token es valido:
   - Obtener el user_id asociado.
   - Hashear new_password.
   - Actualizar user.hashed_password.
   - Marcar el token como usado (used = True).
3. Retornar mensaje de exito.

Respuesta exitosa:
{
  "message": "Password reset successfully"
}

Errores posibles:
- 400 Bad Request si el token es invalido, expirado o ya usado.

===============================================================================
              FASE 4: BACKEND - SISTEMA DE NOTIFICACIONES
===============================================================================

-------------------------------------------------------------------------------
Prompt 4.1: Endpoint para Obtener Notificaciones
-------------------------------------------------------------------------------

Crea un nuevo archivo "gymcore/backend/app/api/routes/notifications.py" con 
el siguiente endpoint:

Ruta: GET /api/notifications
Descripcion: Retorna las notificaciones del gimnasio (alertas, eventos, 
avisos).
Autenticacion: Requiere JWT token valido.

Logica:
1. Obtener el usuario actual.
2. Buscar notificaciones del gimnasio en una nueva tabla "Notification":
   - Filtrar por gym_id = current_user.gym_id.
   - Ordenar por created_at DESC.
   - Limitar a las ultimas 10 notificaciones no leidas + las 5 mas recientes 
     leidas.
3. Retornar la lista de notificaciones.

Modelo de BD (añadir a "gymcore/backend/app/infrastructure/database.py"):

class NotificationModel(Base):
    __tablename__ = "notifications"
    id = Column(Integer, primary_key=True, index=True)
    gym_id = Column(Integer, ForeignKey("gyms.id"))
    title = Column(String(255))
    message = Column(Text)
    type = Column(String(50))  # 'info', 'warning', 'success', 'error'
    is_read = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)

Schema de Response:

from datetime import datetime
from typing import List

class NotificationResponse(BaseModel):
    id: int
    title: str
    message: str
    type: str
    is_read: bool
    created_at: datetime

    class Config:
        from_attributes = True

Respuesta exitosa: Lista de "NotificationResponse".

Endpoint adicional: POST /api/notifications/{id}/mark-read
- Marca una notificacion como leida (is_read = True).

===============================================================================
               FASE 5: FRONTEND - PANTALLA DE CONFIGURACION
===============================================================================

-------------------------------------------------------------------------------
Prompt 5.1: Implementar Formulario de Perfil de Usuario
-------------------------------------------------------------------------------

En el archivo "gymcore/frontend/src/pages/Dashboard/SettingsPage.jsx", 
implementa la pestaña "Perfil" con el siguiente contenido:

Componente: ProfileTab
Descripcion: Formulario para actualizar el nombre completo y email del 
usuario administrador.

Estado local:

const [formData, setFormData] = useState({
  full_name: user.full_name,
  email: user.email
});
const [isLoading, setIsLoading] = useState(false);
const [message, setMessage] = useState({ type: '', text: '' });

Logica de submit:
1. Validar que los campos no esten vacios.
2. Hacer un PUT /api/users/me con formData.
3. Si es exitoso:
   - Actualizar el contexto AuthContext con los nuevos datos.
   - Mostrar mensaje de exito temporal.
4. Si hay error:
   - Mostrar mensaje de error (ej: "El email ya esta en uso").

UI del formulario:
- Input para "Nombre Completo" (text input).
- Input para "Email" (email input).
- Boton "Guardar Cambios" (primary button).
- Mostrar mensaje de exito/error debajo del boton.

Estilos: Usar los mismos estilos de los formularios existentes (Tailwind CSS 
con tema dark).

-------------------------------------------------------------------------------
Prompt 5.2: Implementar Formulario de Perfil del Gimnasio
-------------------------------------------------------------------------------

En el archivo "gymcore/frontend/src/pages/Dashboard/SettingsPage.jsx", 
implementa la pestaña "Gimnasio" con el siguiente contenido:

Componente: GymTab
Descripcion: Formulario para actualizar los datos del negocio (nombre, email, 
telefono, direccion).

Estado local:

const [gymData, setGymData] = useState({
  name: gym.name,
  email: gym.email,
  phone: gym.phone,
  address: gym.address
});
const [isLoading, setIsLoading] = useState(false);
const [message, setMessage] = useState({ type: '', text: '' });

Logica de submit:
1. Validar que los campos no esten vacios.
2. Hacer un PUT /api/gyms/me con gymData.
3. Si es exitoso:
   - Actualizar el contexto AuthContext con los nuevos datos del gym.
   - Mostrar mensaje de exito.
4. Si hay error:
   - Mostrar mensaje de error.

UI del formulario:
- Input para "Nombre del Gimnasio".
- Input para "Email del Gimnasio".
- Input para "Telefono".
- Textarea para "Direccion".
- Boton "Guardar Cambios".
- Mensaje de exito/error.

-------------------------------------------------------------------------------
Prompt 5.3: Implementar Formulario de Cambio de Contraseña
-------------------------------------------------------------------------------

En el archivo "gymcore/frontend/src/pages/Dashboard/SettingsPage.jsx", 
implementa la pestaña "Seguridad" con el siguiente contenido:

Componente: SecurityTab
Descripcion: Formulario para cambiar la contraseña del usuario.

Estado local:

const [passwordData, setPasswordData] = useState({
  current_password: '',
  new_password: '',
  confirm_password: ''
});
const [showPassword, setShowPassword] = useState({
  current: false,
  new: false,
  confirm: false
});
const [isLoading, setIsLoading] = useState(false);
const [message, setMessage] = useState({ type: '', text: '' });

Validaciones del frontend:
1. new_password debe tener al menos 8 caracteres.
2. new_password debe ser igual a confirm_password.
3. current_password no puede estar vacio.

Logica de submit:
1. Validar los campos.
2. Hacer un POST /api/auth/change-password con 
   { current_password, new_password }.
3. Si es exitoso:
   - Limpiar el formulario.
   - Mostrar mensaje de exito.
4. Si hay error:
   - Mostrar mensaje de error (ej: "La contraseña actual es incorrecta").

UI del formulario:
- Input para "Contraseña Actual" con toggle de visibilidad.
- Input para "Nueva Contraseña" con toggle de visibilidad.
- Input para "Confirmar Nueva Contraseña" con toggle de visibilidad.
- Boton "Cambiar Contraseña".
- Mensaje de exito/error.

Iconos: Usar Eye y EyeOff de lucide-react para el toggle de visibilidad.

-------------------------------------------------------------------------------
Prompt 5.4: Implementar Sistema de Pestañas Funcional
-------------------------------------------------------------------------------

En el archivo "gymcore/frontend/src/pages/Dashboard/SettingsPage.jsx", 
implementa el sistema de navegacion por pestañas:

Estado local:

const [activeTab, setActiveTab] = useState('profile');

Navegacion:
- Tres botones: "Perfil", "Gimnasio", "Seguridad".
- Al hacer clic en un boton, cambiar activeTab al valor correspondiente.
- Aplicar estilos condicionales:
  - Activo: border-lime-400 text-lime-400
  - Inactivo: border-transparent text-slate-400 hover:text-slate-300

Renderizado condicional:

{activeTab === 'profile' && <ProfileTab />}
{activeTab === 'gym' && <GymTab />}
{activeTab === 'security' && <SecurityTab />}

Reemplazar el placeholder actual ("En Desarrollo") por este sistema 
funcional.

===============================================================================
                FASE 6: FRONTEND - PANTALLA DE FACTURACION
===============================================================================

-------------------------------------------------------------------------------
Prompt 6.1: Conectar Datos Reales de Suscripcion
-------------------------------------------------------------------------------

En el archivo "gymcore/frontend/src/pages/Dashboard/BillingPage.jsx", 
conecta los datos reales desde el backend:

Fetch de datos al montar el componente:

useEffect(() => {
  const fetchBillingData = async () => {
    try {
      const [subResponse, invoicesResponse] = await Promise.all([
        fetch('/api/billing/subscription', 
              { headers: { Authorization: `Bearer ${token}` } }),
        fetch('/api/billing/invoices', 
              { headers: { Authorization: `Bearer ${token}` } })
      ]);
      
      const subscription = await subResponse.json();
      const invoices = await invoicesResponse.json();
      
      setSubscriptionData(subscription);
      setInvoices(invoices);
    } catch (error) {
      console.error('Error fetching billing data:', error);
    }
  };
  
  fetchBillingData();
}, [token]);

Mostrar datos dinamicos:
- Plan actual: {subscriptionData.plan_type} (en lugar de gym.plan_type fijo).
- Fecha de renovacion: Calcular desde subscriptionData.end_date.
- Estado: "ACTIVO" si subscription.status === 'active'.

-------------------------------------------------------------------------------
Prompt 6.2: Implementar Boton "Cancelar Suscripcion"
-------------------------------------------------------------------------------

En el archivo "gymcore/frontend/src/pages/Dashboard/BillingPage.jsx", 
implementa la funcionalidad del boton "Cancelar Suscripcion":

Modal de confirmacion:

const [showCancelModal, setShowCancelModal] = useState(false);

const handleCancelSubscription = async () => {
  try {
    const response = await fetch('/api/billing/cancel-subscription', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (response.ok) {
      const result = await response.json();
      alert(`Suscripcion cancelada. Tendras acceso hasta 
            ${new Date(result.access_until).toLocaleDateString()}`);
      setShowCancelModal(false);
      // Recargar datos de suscripcion
    }
  } catch (error) {
    alert('Error al cancelar la suscripcion');
  }
};

UI del modal:
- Titulo: "¿Estas seguro de cancelar tu suscripcion?"
- Mensaje: "Mantendras acceso hasta el final del periodo pagado."
- Botones: "Cancelar" (secundario) y "Confirmar Cancelacion" 
  (destructivo/rojo).
- Usar el componente Modal existente o crear uno simple con Tailwind.

-------------------------------------------------------------------------------
Prompt 6.3: Implementar Boton "Cambiar Plan"
-------------------------------------------------------------------------------

En el archivo "gymcore/frontend/src/pages/Dashboard/BillingPage.jsx", 
habilita el boton "Cambiar Plan":

Estado local:

const [showPlanModal, setShowPlanModal] = useState(false);
const [selectedPlan, setSelectedPlan] = useState(gym.plan_type);

Modal de seleccion de plan:
- Mostrar tres tarjetas: Basic ($29/mes), Pro ($59/mes), Elite ($99/mes).
- Resaltar el plan actual.
- Al seleccionar un plan diferente, habilitar boton "Confirmar Cambio".

Logica de submit:

const handleChangePlan = async () => {
  try {
    const response = await fetch('/api/billing/change-plan', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ new_plan: selectedPlan })
    });
    
    if (response.ok) {
      const result = await response.json();
      alert(`Plan cambiado a ${result.new_plan} exitosamente`);
      setShowPlanModal(false);
      // Actualizar contexto con el nuevo plan
    }
  } catch (error) {
    alert('Error al cambiar el plan');
  }
};

Remover el "disabled" del boton y quitar el tooltip "Proximamente".

-------------------------------------------------------------------------------
Prompt 6.4: Implementar Boton "Actualizar Metodo de Pago"
-------------------------------------------------------------------------------

En el archivo "gymcore/frontend/src/pages/Dashboard/BillingPage.jsx", 
implementa la funcionalidad del boton "Actualizar Metodo de Pago":

Estado local:

const [showPaymentModal, setShowPaymentModal] = useState(false);
const [paymentData, setPaymentData] = useState({
  card_number: '',
  expiry_month: '',
  expiry_year: '',
  cvv: ''
});

Modal de actualizacion de tarjeta:
- Input para numero de tarjeta (16 digitos).
- Dos inputs pequeños: mes de expiracion (01-12) y año (YYYY).
- Input para CVV (3-4 digitos).
- Boton "Guardar Metodo de Pago".

Logica de submit:

const handleUpdatePaymentMethod = async () => {
  try {
    const response = await fetch('/api/billing/payment-method', {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(paymentData)
    });
    
    if (response.ok) {
      const result = await response.json();
      alert('Metodo de pago actualizado');
      setShowPaymentModal(false);
      // Actualizar UI con los nuevos ultimos 4 digitos
    }
  } catch (error) {
    alert('Error al actualizar el metodo de pago');
  }
};

Validaciones del frontend:
- Numero de tarjeta: 16 digitos.
- Mes de expiracion: 1-12.
- Año de expiracion: >= 2025.
- CVV: 3-4 digitos.

-------------------------------------------------------------------------------
Prompt 6.5: Implementar Historial de Facturas
-------------------------------------------------------------------------------

En el archivo "gymcore/frontend/src/pages/Dashboard/BillingPage.jsx", 
reemplaza el placeholder del historial de pagos por datos reales:

Fetch de facturas (ya implementado en Prompt 6.1).

Renderizado condicional:

{invoices.length === 0 ? (
  <div className="rounded-lg border border-slate-800 bg-slate-950 p-8 
                  text-center">
    <Calendar className="mx-auto mb-3 h-10 w-10 text-slate-600" />
    <p className="text-slate-400">
      No hay facturas anteriores para mostrar.
    </p>
  </div>
) : (
  <div className="overflow-hidden rounded-lg border border-slate-800">
    <table className="w-full">
      <thead className="bg-slate-950">
        <tr>
          <th className="px-6 py-3 text-left text-xs font-medium uppercase 
                         text-slate-400">
            Fecha
          </th>
          <th className="px-6 py-3 text-left text-xs font-medium uppercase 
                         text-slate-400">
            Plan
          </th>
          <th className="px-6 py-3 text-left text-xs font-medium uppercase 
                         text-slate-400">
            Monto
          </th>
          <th className="px-6 py-3 text-left text-xs font-medium uppercase 
                         text-slate-400">
            Estado
          </th>
        </tr>
      </thead>
      <tbody className="divide-y divide-slate-800 bg-slate-900">
        {invoices.map(invoice => (
          <tr key={invoice.id}>
            <td className="px-6 py-4 text-sm text-slate-300">
              {new Date(invoice.date).toLocaleDateString()}
            </td>
            <td className="px-6 py-4 text-sm text-slate-300 uppercase">
              {invoice.plan}
            </td>
            <td className="px-6 py-4 text-sm text-slate-300">
              ${invoice.amount}
            </td>
            <td className="px-6 py-4 text-sm">
              <span className="rounded-full bg-green-400/10 px-2 py-1 
                               text-xs text-green-400">
                {invoice.status}
              </span>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  </div>
)}

===============================================================================
             FASE 7: FRONTEND - RECUPERACION DE CONTRASEÑA
===============================================================================

-------------------------------------------------------------------------------
Prompt 7.1: Crear Pagina "Forgot Password"
-------------------------------------------------------------------------------

Crea el archivo "gymcore/frontend/src/pages/Auth/ForgotPasswordPage.jsx" con 
el siguiente contenido:

Descripcion: Pagina para solicitar el restablecimiento de contraseña.

Estado local:

const [email, setEmail] = useState('');
const [isSubmitted, setIsSubmitted] = useState(false);
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState('');

Logica de submit:

const handleSubmit = async (e) => {
  e.preventDefault();
  setIsLoading(true);
  setError('');
  
  try {
    const response = await fetch('/api/auth/forgot-password', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email })
    });
    
    if (response.ok) {
      setIsSubmitted(true);
    }
  } catch (error) {
    setError('Hubo un error. Por favor intenta nuevamente.');
  } finally {
    setIsLoading(false);
  }
};

UI:
- Contenedor centrado con diseño similar a LoginPage.
- Logo y titulo "Recuperar Contraseña".
- Input para email.
- Boton "Enviar enlace de recuperacion".
- Si isSubmitted === true, mostrar mensaje: "Si el email existe, recibiras 
  un enlace de recuperacion."
- Link de regreso: "Volver al inicio de sesion" -> /login.

Ruta: Añadir en App.jsx:

<Route path="/forgot-password" element={<ForgotPasswordPage />} />

-------------------------------------------------------------------------------
Prompt 7.2: Crear Pagina "Reset Password"
-------------------------------------------------------------------------------

Crea el archivo "gymcore/frontend/src/pages/Auth/ResetPasswordPage.jsx" con 
el siguiente contenido:

Descripcion: Pagina para establecer una nueva contraseña usando el token de 
recuperacion.

Obtener el token de la URL:

import { useSearchParams } from 'react-router-dom';

const [searchParams] = useSearchParams();
const token = searchParams.get('token');

Estado local:

const [passwords, setPasswords] = useState({
  new_password: '',
  confirm_password: ''
});
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState('');
const [success, setSuccess] = useState(false);

Validaciones:
1. new_password debe tener al menos 8 caracteres.
2. new_password === confirm_password.

Logica de submit:

const handleSubmit = async (e) => {
  e.preventDefault();
  
  if (passwords.new_password !== passwords.confirm_password) {
    setError('Las contraseñas no coinciden');
    return;
  }
  
  setIsLoading(true);
  setError('');
  
  try {
    const response = await fetch('/api/auth/reset-password', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token, new_password: passwords.new_password })
    });
    
    if (response.ok) {
      setSuccess(true);
      setTimeout(() => navigate('/login'), 3000);
    } else {
      setError('El enlace de recuperacion es invalido o expiro.');
    }
  } catch (error) {
    setError('Hubo un error. Por favor intenta nuevamente.');
  } finally {
    setIsLoading(false);
  }
};

UI:
- Diseño similar a LoginPage.
- Titulo "Establecer Nueva Contraseña".
- Input para "Nueva Contraseña".
- Input para "Confirmar Contraseña".
- Boton "Restablecer Contraseña".
- Si success === true, mostrar: "Contraseña actualizada. Redirigiendo..." y 
  redirigir al login.

Ruta: Añadir en App.jsx:

<Route path="/reset-password" element={<ResetPasswordPage />} />

-------------------------------------------------------------------------------
Prompt 7.3: Conectar Link en LoginPage
-------------------------------------------------------------------------------

En el archivo "gymcore/frontend/src/pages/Auth/LoginPage.jsx", actualiza el 
enlace "¿Olvidaste tu contraseña?" para que apunte a la nueva pagina:

Cambiar:

<a href="#" className="...">¿Olvidaste tu contraseña?</a>

Por:

<Link to="/forgot-password" className="...">¿Olvidaste tu contraseña?</Link>

Importar Link:

import { Link } from 'react-router-dom';

===============================================================================
               FASE 8: FRONTEND - SISTEMA DE NOTIFICACIONES
===============================================================================

-------------------------------------------------------------------------------
Prompt 8.1: Implementar Dropdown de Notificaciones
-------------------------------------------------------------------------------

En el archivo "gymcore/frontend/src/components/Navbar.jsx", implementa el 
dropdown de notificaciones:

Estado local:

const [showNotifications, setShowNotifications] = useState(false);
const [notifications, setNotifications] = useState([]);
const [unreadCount, setUnreadCount] = useState(0);

Fetch de notificaciones:

useEffect(() => {
  const fetchNotifications = async () => {
    try {
      const response = await fetch('/api/notifications', {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      const data = await response.json();
      setNotifications(data);
      setUnreadCount(data.filter(n => !n.is_read).length);
    } catch (error) {
      console.error('Error fetching notifications:', error);
    }
  };
  
  if (token) {
    fetchNotifications();
    // Refrescar cada 30 segundos
    const interval = setInterval(fetchNotifications, 30000);
    return () => clearInterval(interval);
  }
}, [token]);

UI del dropdown:
- Al hacer clic en el icono de campana, mostrar/ocultar el dropdown.
- Badge con el numero de notificaciones no leidas (unreadCount).
- Lista de notificaciones con:
  - Titulo en negrita.
  - Mensaje truncado.
  - Fecha relativa (ej: "Hace 2 horas").
  - Punto de color segun el tipo (info = azul, warning = amarillo, 
    success = verde, error = rojo).
- Boton "Marcar todas como leidas" al final.

Marcar como leida al hacer clic:

const markAsRead = async (id) => {
  try {
    await fetch(`/api/notifications/${id}/mark-read`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${token}` }
    });
    // Actualizar estado local
    setNotifications(notifications.map(n => 
      n.id === id ? { ...n, is_read: true } : n
    ));
    setUnreadCount(unreadCount - 1);
  } catch (error) {
    console.error('Error marking notification as read:', error);
  }
};

Estilos: Dropdown posicionado absolutamente debajo del icono, con ancho fijo 
(320px), fondo oscuro y scroll si hay muchas notificaciones.

===============================================================================
                           NOTAS ADICIONALES
===============================================================================

PRIORIZACION SUGERIDA
----------------------
1. Alta Prioridad: Fases 1, 2, 5 y 6 (configuracion y facturacion son 
   criticas para la gestion del negocio).
2. Media Prioridad: Fase 3 (recuperacion de contraseña es importante para 
   UX, pero no bloquea operacion).
3. Baja Prioridad: Fase 4 y 8 (notificaciones son nice-to-have, no 
   esenciales).

CONSIDERACIONES DE SEGURIDAD
-----------------------------
- Tokens JWT: Asegurarse de que expiren en tiempos razonables (1-2 horas).
- Passwords: Usar bcrypt con al menos 10 rondas de hashing.
- Tokens de recuperacion: Expirar en 1 hora maximo.
- Rate Limiting: Considerar añadir limites de requests (ej: no mas de 5 
  intentos de login por minuto).

TESTING RECOMENDADO
--------------------
Despues de implementar cada fase:
1. Probar manualmente cada endpoint con herramientas como Postman.
2. Verificar que los formularios del frontend muestren errores correctamente.
3. Probar flujos completos (ej: registro -> pago -> cambiar plan -> 
   cancelar).

MEJORAS FUTURAS (POST-MVP)
---------------------------
- Integracion con procesador de pagos real (Stripe/PayPal).
- Envio de emails reales (usando SendGrid o similar).
- Dashboard de analiticas avanzadas (metricas de retencion, churn, etc.).
- Roles de usuario adicionales (recepcionista, entrenador).
- Aplicacion movil para miembros del gimnasio.

===============================================================================
                   FIN DEL DOCUMENTO DE IMPLEMENTACION
===============================================================================

Este documento contiene todos los prompts necesarios para que un desarrollador 
(o un LLM) implemente las funcionalidades faltantes de manera ordenada y 
completa. Cada prompt esta diseñado para ser autocontenido y ejecutable de 
forma independiente.
